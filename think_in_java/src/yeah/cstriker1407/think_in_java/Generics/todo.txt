 
 
 
 
 http://qiemengdao.iteye.com/blog/1525624 
 
 
     类型擦除指的是通过类型参数合并，将泛型类型实例关联到同一份字节码上。编译器只为泛型类型生成一份字节码，并将其实例关联到这份字节码上，因此泛型类型中的静态变量是所有实例共享的。此外，需要注意的是，一个static方法，无法访问泛型类的类型参数，因为类还没有实例化，所以，若static方法需要使用泛型能力，必须使其成为泛型方法。类型擦除的关键在于从泛型类型中清除类型参数的相关信息，并且再必要的时候添加类型检查和类型转换的方法。在使用泛型时，任何具体的类型都被擦除，唯一知道的是你在使用一个对象。比如：List<String>和List<Integer>在运行事实上是相同的类型。他们都被擦除成他们的原生类型，即List。因为编译的时候会有类型擦除，所以不能通过同一个泛型类的实例来区分方法，如下面的例子编译时会出错，因为类型擦除后，两个方法都是List类型的参数，因此并不能根据泛型类的类型来区分方法。
 
Java代码  
/*会导致编译时错误*/   
 public class Erasure{  
            public void test(List<String> ls){  
                System.out.println("Sting");  
            }  
            public void test(List<Integer> li){  
                System.out.println("Integer");  
            }  
  }  
 
       那么这就有个问题了，既然在编译的时候会在方法和类中擦除实际类型的信息，那么在返回对象时又是如何知道其具体类型的呢？如List<String>编译后会擦除掉String信息，那么在运行时通过迭代器返回List中的对象时，又是如何知道List中存储的是String类型对象呢？
       擦除在方法体中移除了类型信息，所以在运行时的问题就是边界：即对象进入和离开方法的地点，这正是编译器在编译期执行类型检查并插入转型代码的地点。泛型中的所有动作都发生在边界处：对传递进来的值进行额外的编译期检查，并插入对传递出去的值的转型。
 
 
 
 
 
3.泛型和子类型
为了彻底理解泛型，这里看个例子：（Apple为Fruit的子类）
 
Java代码  
List<Apple> apples = new ArrayList<Apple>(); //1  
List<Fruit> fruits = apples; //2  
 
第1行代码显然是对的，但是第2行是否对呢？我们知道Fruit fruit = new Apple()，这样肯定是对的，即苹果肯定是水果，但是第2行在编译的时候会出错。这会让人比较纳闷的是一个苹果是水果，为什么一箱苹果就不是一箱水果了呢？可以这样考虑，我们假定第2行代码没有问题，那么我们可以使用语句fruits.add(new Strawberry())（Strawberry为Fruit的子类）在fruits中加入草莓了，但是这样的话，一个List中装入了各种不同类型的子类水果，这显然是不可以的，因为我们在取出List中的水果对象时，就分不清楚到底该转型为苹果还是草莓了。
通常来说，如果Foo是Bar的子类型，G是一种带泛型的类型，则G<Foo>不是G<Bar>的子类型。这也许是泛型学习里面最让人容易混淆的一点。










